#!/usr/bin/env bash

set -o errexit           # treat errors as fatal
set -o nounset           # treat unset variables as an error
set -o pipefail          # treat errors in pipes as fatal
shopt -s inherit_errexit # inherit errexit

LOGLEVEL="${LOGLEVEL:="INFO"}"

# make it possible to disable the inotify watcher process
ENABLE_RESCAN_ON_FILESYSTEM_CHANGE="${ENABLE_RESCAN_ON_FILESYSTEM_CHANGE:="false"}"
ENABLE_SCHEDULED_RESCAN="${ENABLE_SCHEDULED_RESCAN:="false"}"
ENABLE_SCHEDULED_UPDATE_LAUNCHBOX_METADATA="${ENABLE_SCHEDULED_UPDATE_LAUNCHBOX_METADATA:="false"}"
ENABLE_SCHEDULED_UPDATE_SWITCH_TITLEDB="${ENABLE_SCHEDULED_UPDATE_SWITCH_TITLEDB:="false"}"

# if REDIS_HOST is set, we assume that an external redis is used
REDIS_HOST="${REDIS_HOST:=""}"

is_truthy() {
	local v="${1:-}"
	v="$(echo "${v}" | tr '[:upper:]' '[:lower:]' | xargs)"
	case "${v}" in
	1|true|yes|on) return 0 ;;
	*) return 1 ;;
	esac
}

# logger colors
RED='\033[0;31m'
LIGHTMAGENTA='\033[0;95m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
RESET='\033[0;00m'

print_banner() {
	local version
	version=$(python3 -c "exec(open('__version__.py').read()); print(__version__)")
	info_log "               _____                 __  __ "
	info_log '              |  __ \               |  \/  |'
	info_log '              | |__) |___  _ __ ___ | \  / |'
	info_log "              |  _  // _ \\| '_ \` _ \\| |\\/| |"
	info_log '              | | \ \ (_) | | | | | | |  | |'
	info_log '              |_|  \_\___/|_| |_| |_|_|  |_|'
	info_log ""
	info_log "The beautiful, powerful, self-hosted Rom manager and player"
	info_log ""
	info_log "Version: ${version}"
	info_log ""
}

debug_log() {
	# print debug log output if enabled
	if [[ ${LOGLEVEL} == "DEBUG" ]]; then
		echo -e "${LIGHTMAGENTA}DEBUG:    ${BLUE}[RomM]${LIGHTMAGENTA}[init]${CYAN}[$(date +"%Y-%m-%d %T")]${RESET}" "${@}" || true
	fi
}

info_log() {
	echo -e "${GREEN}INFO:     ${BLUE}[RomM]${LIGHTMAGENTA}[init]${CYAN}[$(date +"%Y-%m-%d %T")]${RESET}" "${@}" || true
}

warn_log() {
	echo -e "${YELLOW}WARNING:  ${BLUE}[RomM]${LIGHTMAGENTA}[init]${CYAN}[$(date +"%Y-%m-%d %T")]${RESET}" "${@}" || true
}

error_log() {
	echo -e "${RED}ERROR:    ${BLUE}[RomM]${LIGHTMAGENTA}[init]${CYAN}[$(date +"%Y-%m-%d %T")]${RESET}" "${@}" || true
	exit 1
}

# Commands to run initial startup tasks
run_startup() {
	if ! PYTHONPATH="/backend:${PYTHONPATH-}" opentelemetry-instrument \
		--service_name "${OTEL_SERVICE_NAME_PREFIX-}startup" \
		python3 /backend/startup.py; then
		error_log "Startup script failed, exiting"
	fi
}

wait_for_gunicorn_socket() {
	debug_log "Waiting for gunicorn socket file..."
	local retries=60
	while [[ ! -S /tmp/gunicorn.sock && retries -gt 0 ]]; do
		sleep 0.5
		((retries--))
	done

	if [[ -S /tmp/gunicorn.sock ]]; then
		debug_log "Gunicorn socket file found"
	else
		warn_log "Gunicorn socket file not found after waiting 30s!"
	fi
}

# function that runs or main process and creates a corresponding PID file,
start_bin_gunicorn() {
	# cleanup potentially leftover socket
	rm /tmp/gunicorn.sock -f

	# commands to start our main application and store its PID to check for crashes
	info_log "Starting backend"

	export PYTHONUNBUFFERED=1
	export PYTHONDONTWRITEBYTECODE=1

	opentelemetry-instrument \
		--service_name "${OTEL_SERVICE_NAME_PREFIX-}api" \
		gunicorn \
		--bind=0.0.0.0:"${DEV_PORT:-5000}" \
		--bind=unix:/tmp/gunicorn.sock \
		--pid=/tmp/gunicorn.pid \
		--forwarded-allow-ips="*" \
		--worker-class uvicorn_worker.UvicornWorker \
		--workers "${WEB_SERVER_CONCURRENCY:-1}" \
		--timeout "${WEB_SERVER_TIMEOUT:-300}" \
		--keep-alive "${WEB_SERVER_KEEPALIVE:-2}" \
		--max-requests "${WEB_SERVER_MAX_REQUESTS:-1000}" \
		--max-requests-jitter "${WEB_SERVER_MAX_REQUESTS_JITTER:-100}" \
		--worker-connections "${WEB_SERVER_WORKER_CONNECTIONS:-1000}" \
		--error-logfile - \
		--log-config /etc/gunicorn/logging.conf \
		main:app &
}

# Commands to start nginx (handling PID creation internally)
start_bin_nginx() {
	wait_for_gunicorn_socket

	info_log "Starting nginx"
	if [[ ${EUID} -ne 0 ]]; then
		nginx
	else
		# if container runs as root, drop permissions
		nginx -g 'user romm;'
	fi

	: "${ROMM_BASE_URL:=http://0.0.0.0:8080}"
	info_log "ðŸš€ RomM is now available at ${ROMM_BASE_URL}"
}

# Commands to start valkey-server (handling PID creation internally)
start_bin_valkey-server() {
	info_log "Starting internal valkey"

	# Internal Valkey defaults to loopback-only (safe). To allow other containers
	# (e.g. EmulatorJS-SFU) to connect, opt-in by setting:
	#   ROMM_INTERNAL_VALKEY_EXPOSE=true
	# When exposed, ACL is REQUIRED and Valkey will be started with a generated
	# ACL file in /redis-data.
	local expose="${ROMM_INTERNAL_VALKEY_EXPOSE:-false}"
	local enable_acl="${ROMM_INTERNAL_VALKEY_ENABLE_ACL:-}"
	local bind_addr="${ROMM_INTERNAL_VALKEY_BIND:-}"
	local protected_mode="${ROMM_INTERNAL_VALKEY_PROTECTED_MODE:-}"
	local port="${REDIS_PORT:-6379}"
	local data_dir="${ROMM_INTERNAL_VALKEY_DATA_DIR:-/redis-data}"
	local acl_file="${ROMM_INTERNAL_VALKEY_ACL_FILE:-${data_dir}/users.acl}"

	if [[ -z ${bind_addr} ]]; then
		if is_truthy "${expose}"; then
			bind_addr="0.0.0.0"
		else
			bind_addr="127.0.0.1"
		fi
	fi

	# Auto-enable ACL when exposing, or when SFU password is provided.
	if [[ -z ${enable_acl} ]]; then
		if is_truthy "${expose}" || [[ -n ${VALKEY_SFU_PASSWORD-} ]]; then
			enable_acl="true"
		else
			enable_acl="false"
		fi
	fi

	if [[ -z ${protected_mode} ]]; then
		# Protected-mode should be off when binding non-loopback.
		if [[ ${bind_addr} == "127.0.0.1" || ${bind_addr} == "::1" ]]; then
			protected_mode="yes"
		else
			protected_mode="no"
		fi
	fi

	# If exposing internal Valkey, require ACL (fail closed).
	if is_truthy "${expose}" && ! is_truthy "${enable_acl}"; then
		error_log "ROMM_INTERNAL_VALKEY_EXPOSE is enabled but ROMM_INTERNAL_VALKEY_ENABLE_ACL is false. Refusing to expose Valkey without ACL."
	fi

	ensure_internal_valkey_acl_file() {
		# Generate an ACL file inside the writable /redis-data volume.
		# Two users:
		# - romm: full access (RomM backend + workers)
		# - sfu: restricted to sfu:* keyspace
		local romm_pw="${VALKEY_ROMM_PASSWORD:-${REDIS_PASSWORD:-${ROMM_AUTH_SECRET_KEY:-}}}"
		local sfu_pw="${VALKEY_SFU_PASSWORD:-}"

		if [[ -z ${romm_pw} || -z ${sfu_pw} ]]; then
			error_log "Internal Valkey ACL enabled but missing romm password (VALKEY_ROMM_PASSWORD/REDIS_PASSWORD/ROMM_AUTH_SECRET_KEY) and/or VALKEY_SFU_PASSWORD"
		fi

		# Ensure RomM itself uses the ACL user by default when internal Valkey is used.
		export REDIS_USERNAME="${REDIS_USERNAME:-romm}"
		export REDIS_PASSWORD="${romm_pw}"
		export REDIS_HOST="${REDIS_HOST:-127.0.0.1}"
		export REDIS_PORT="${port}"

		if [[ -f ${acl_file} ]]; then
			# Valkey is strict about ACL file contents. Keep it to only `user ...` lines.
			# If we detect any non-user lines (comments/blank lines), regenerate a clean file.
			if grep -qvE '^user\s+\S+' "${acl_file}"; then
				warn_log "Detected invalid lines in internal Valkey ACL file; regenerating" "(${acl_file})"
				rm -f "${acl_file}" || true
			else
			# Existing deployments may have an ACL file that is missing entries.
			# When updating an existing user, DO NOT append a second `user <name> ...` line
			# because Valkey/Redis ACL lines behave like `ACL SETUSER` commands and can
			# accumulate key/channel patterns (e.g. a legacy `~*` would remain). Instead,
			# rewrite the user's line.
			rewrite_acl_user_line() {
				local user_name="${1:-}"
				shift || true
				local new_line="$*"
				if [[ -z ${user_name} || -z ${new_line} ]]; then
					return 1
				fi
				local tmp
				tmp="$(mktemp)"
				# Keep file strict: only `user ...` lines.
				grep -vE "^user\\s+${user_name}\\b" "${acl_file}" >"${tmp}" 2>/dev/null || true
				echo "${new_line}" >>"${tmp}" || true
				mv "${tmp}" "${acl_file}" || true
				chmod 600 "${acl_file}" || true
			}
			# Do not fail here; instead, ensure at least the security-critical
			# defaults are present and let runtime verification handle rotations.
			umask 077
			if ! grep -qE '^user\s+default\s+off\b' "${acl_file}"; then
				echo "user default off" >>"${acl_file}" || true
			fi
			# If the SFU user is missing, add it now (does not affect existing users).
			if ! grep -qE '^user\s+sfu\b' "${acl_file}"; then
				rewrite_acl_user_line sfu "user sfu resetpass resetkeys resetchannels on >${sfu_pw} ~sfu:* &* -@all +ping +get +set +del +mget +scan +hgetall +hset +expire +ttl +setnx +eval +select"
			fi
			return 0
			fi
		fi

		info_log "Generating internal Valkey ACL file" "(${acl_file})"
		mkdir -p "$(dirname "${acl_file}")"
		umask 077
		cat >"${acl_file}" <<EOF
user default off
user romm on >${romm_pw} ~* &* +@all
user sfu resetpass resetkeys resetchannels on >${sfu_pw} ~sfu:* &* -@all +ping +get +set +del +mget +scan +hgetall +hset +expire +ttl +setnx +eval +select
EOF
		chmod 600 "${acl_file}" || true
	}

	verify_internal_valkey_acl_runtime() {
		# Runtime auth verification using valkey-cli/redis-cli (if present).
		local desired_romm_pw="${VALKEY_ROMM_PASSWORD:-}"
		local romm_pw="${VALKEY_ROMM_PASSWORD:-${REDIS_PASSWORD:-${ROMM_AUTH_SECRET_KEY:-}}}"
		local legacy_romm_pw="${ROMM_AUTH_SECRET_KEY:-}"
		local sfu_pw="${VALKEY_SFU_PASSWORD:-}"
		local legacy_sfu_pw="${ROMM_AUTH_SECRET_KEY:-}"

		local cli_bin=""
		if command -v valkey-cli >/dev/null 2>&1; then
			cli_bin="valkey-cli"
		elif command -v redis-cli >/dev/null 2>&1; then
			cli_bin="redis-cli"
		else
			warn_log "valkey-cli/redis-cli not found; skipping ACL runtime verification"
			return 0
		fi

		valkey_cli_ping() {
			local user="${1:-}"
			local pass="${2:-}"
			if [[ -z ${user} || -z ${pass} ]]; then
				return 1
			fi
			"${cli_bin}" -h 127.0.0.1 -p "${port}" --user "${user}" -a "${pass}" ping >/dev/null 2>&1
		}

		rewrite_acl_user_line() {
			local user_name="${1:-}"
			shift || true
			local new_line="$*"
			if [[ -z ${user_name} || -z ${new_line} ]]; then
				return 1
			fi
			if [[ ! -f ${acl_file} ]]; then
				return 1
			fi
			local tmp
			tmp="$(mktemp)"
			grep -vE "^user\\s+${user_name}\\b" "${acl_file}" >"${tmp}" 2>/dev/null || true
			echo "${new_line}" >>"${tmp}" || true
			mv "${tmp}" "${acl_file}" || true
			chmod 600 "${acl_file}" || true
		}

		wait_for_internal_valkey_ready() {
			local host="127.0.0.1"
			local max_retries=120
			local retry=0
			while ((retry < max_retries)); do
				if (echo >/dev/tcp/"${host}"/"${port}") 2>/dev/null; then
					return 0
				fi
				sleep 0.5
				((retry++))
			done
			return 1
		}

		restart_internal_valkey() {
			info_log "Restarting internal valkey to apply ACL changes"
			local log_file="${ROMM_INTERNAL_VALKEY_LOG_FILE:-/tmp/valkey-server.log}"
			if [[ -n ${VALKEY_PID-} ]]; then
				kill "${VALKEY_PID}" >/dev/null 2>&1 || true
				# wait for process exit
				local tries=200
				while [[ -e "/proc/${VALKEY_PID}" && tries -gt 0 ]]; do
					sleep 0.05
					((tries--))
				done
			fi

			touch "${log_file}" >/dev/null 2>&1 || true
			"${cmd[@]}" >>"${log_file}" 2>&1 &
			VALKEY_PID=$!
			echo "${VALKEY_PID}" >/tmp/valkey-server.pid
			wait_for_internal_valkey_ready || error_log "Internal valkey did not become ready after restart"
		}

		rotate_romm_acl_password_if_needed() {
			# Upgrade path:
			# If VALKEY_ROMM_PASSWORD is set but the existing ACL still uses the old
			# ROMM_AUTH_SECRET_KEY, automatically rotate the 'romm' user's password.
			if [[ -z ${desired_romm_pw} ]]; then
				return 0
			fi
			if [[ ! -f ${acl_file} ]]; then
				return 0
			fi

			# If the desired password already works, we're done.
			if valkey_cli_ping romm "${desired_romm_pw}"; then
				return 0
			fi

			# Otherwise, attempt legacy password.
			if [[ -z ${legacy_romm_pw} ]]; then
				error_log "VALKEY_ROMM_PASSWORD auth failed for 'romm', and ROMM_AUTH_SECRET_KEY is not set for upgrade fallback"
			fi
			if ! valkey_cli_ping romm "${legacy_romm_pw}"; then
				error_log "VALKEY_ROMM_PASSWORD auth failed for 'romm', and legacy ROMM_AUTH_SECRET_KEY auth also failed"
			fi

			info_log "Detected legacy Valkey ACL password for 'romm'; rotating to VALKEY_ROMM_PASSWORD"

			# Upsert by appending a new user definition (last one wins).
			umask 077
			if ! grep -qE '^user\s+default\s+off\b' "${acl_file}"; then
				echo "user default off" >>"${acl_file}" || true
			fi
			rewrite_acl_user_line romm "user romm resetpass resetkeys resetchannels on >${desired_romm_pw} ~* &* +@all"

			restart_internal_valkey
			export REDIS_PASSWORD="${desired_romm_pw}"
			romm_pw="${desired_romm_pw}"

			# Verify new password works after restart.
			valkey_cli_ping romm "${desired_romm_pw}" || error_log "Internal Valkey password rotation failed: VALKEY_ROMM_PASSWORD still does not work for 'romm'"
		}

		ensure_sfu_acl_user_if_needed() {
			# Always validate the SFU user when ACL is enabled.
			if [[ -z ${sfu_pw} ]]; then
				error_log "Internal Valkey ACL enabled but VALKEY_SFU_PASSWORD is not set"
			fi
			if valkey_cli_ping sfu "${sfu_pw}"; then
				return 0
			fi

			# Upgrade/fallback path:
			# Some deployments historically used ROMM_AUTH_SECRET_KEY as the Valkey password.
			# If the desired SFU password fails, try the secret key; if it works, rotate to
			# VALKEY_SFU_PASSWORD so future starts are consistent.
			if [[ -n ${legacy_sfu_pw} ]] && valkey_cli_ping sfu "${legacy_sfu_pw}"; then
				info_log "Detected legacy Valkey ACL password for 'sfu'; rotating to VALKEY_SFU_PASSWORD"
			else
				info_log "SFU Redis ACL user is missing or password mismatch; upserting 'sfu' user"
			fi

			umask 077
			if ! grep -qE '^user\s+default\s+off\b' "${acl_file}"; then
				echo "user default off" >>"${acl_file}" || true
			fi
			rewrite_acl_user_line sfu "user sfu resetpass resetkeys resetchannels on >${sfu_pw} ~sfu:* &* -@all +ping +get +set +del +mget +scan +hgetall +hset +expire +ttl +setnx +eval +select"

			restart_internal_valkey
			valkey_cli_ping sfu "${sfu_pw}" || error_log "Internal Valkey ACL verification failed for user 'sfu' after upsert"
		}

		# If a new romm password is provided, rotate from legacy if needed.
		rotate_romm_acl_password_if_needed

		# Ensure the SFU user is present and correct.
		ensure_sfu_acl_user_if_needed

		# Verify that each user can authenticate.
		valkey_cli_ping romm "${romm_pw}" || error_log "Internal Valkey ACL verification failed for user 'romm'"
		valkey_cli_ping sfu "${sfu_pw}" || error_log "Internal Valkey ACL verification failed for user 'sfu'"

		# Verify sfu keyspace restriction (attempt write outside sfu:* should fail).
		if "${cli_bin}" -h 127.0.0.1 -p "${port}" --user sfu -a "${sfu_pw}" set romm:acl:test 1 >/dev/null 2>&1; then
			error_log "Internal Valkey ACL verification failed: user 'sfu' can write outside sfu:*"
		fi
	}

	if is_truthy "${enable_acl}"; then
		ensure_internal_valkey_acl_file
	fi

	# If a custom config exists, we respect it unless ACL is explicitly enabled.
	# (ACL needs --aclfile so we can ensure it uses /redis-data/users.acl.)
	local cmd=(valkey-server)
	local log_file="${ROMM_INTERNAL_VALKEY_LOG_FILE:-/tmp/valkey-server.log}"
	if is_truthy "${enable_acl}"; then
		cmd+=(--dir "${data_dir}" --aclfile "${acl_file}" --bind "${bind_addr}" --protected-mode "${protected_mode}" --port "${port}")
	else
		if [[ -f /usr/local/etc/valkey/valkey.conf ]]; then
			cmd+=(/usr/local/etc/valkey/valkey.conf)
		else
			cmd+=(--dir "${data_dir}")
		fi
	fi

	# Always log Valkey stdout/stderr to a file to aid debugging. Do not print
	# the log contents automatically (it may include sensitive config/ACL lines).
	# Set LOGLEVEL=DEBUG to see additional RomM init logs.
	touch "${log_file}" >/dev/null 2>&1 || true

	"${cmd[@]}" >>"${log_file}" 2>&1 &

	VALKEY_PID=$!
	echo "${VALKEY_PID}" >/tmp/valkey-server.pid

	local host="127.0.0.1"
	local max_retries=120
	local retry=0

	debug_log "Waiting for internal valkey to be ready..."

	# Temporarily disable errexit for this part of the script
	set +o errexit

	while ((retry < max_retries)); do
		# If the process exited early, surface a clear error.
		if ! kill -0 "${VALKEY_PID}" >/dev/null 2>&1; then
			error_log "Internal valkey exited before becoming ready. Check ${log_file} for details"
		fi

		# Attempt to check if valkey TCP port is open
		if (echo >/dev/tcp/"${host}"/"${port}") 2>/dev/null; then
			debug_log "Internal valkey is ready and accepting connections"
			if is_truthy "${enable_acl}"; then
				verify_internal_valkey_acl_runtime
			fi
			set -o errexit # Re-enable errexit after success
			return 0
		fi

		sleep 0.5
		((retry++))
	done

	error_log "Internal valkey did not become ready after $((max_retries * 500))ms. Check ${log_file} for details"
}

# Commands to start RQ scheduler
start_bin_rq_scheduler() {
	info_log "Starting RQ scheduler"

	RQ_REDIS_HOST=${REDIS_HOST:-127.0.0.1} \
		RQ_REDIS_PORT=${REDIS_PORT:-6379} \
		RQ_REDIS_USERNAME=${REDIS_USERNAME:-""} \
		RQ_REDIS_PASSWORD=${REDIS_PASSWORD:-""} \
		RQ_REDIS_DB=${REDIS_DB:-0} \
		RQ_REDIS_SSL=${REDIS_SSL:-0} \
		rqscheduler \
		--path /backend \
		--pid /tmp/rq_scheduler.pid &
}

# Commands to start RQ worker
start_bin_rq_worker() {
	info_log "Starting RQ worker"

	# Build Redis URL safely.
	# - Avoid bash "${VAR:+s}" gotcha (treats REDIS_SSL=false as truthy)
	# - URL-encode username/password (passwords may contain '@', ':', etc)
	# - Validate port/db are integers (prevents errors like port='eYQ')
	local redis_url
	redis_url=$(
		python3 - <<'PY'
import os
from urllib.parse import quote

def is_truthy(v: str | None) -> bool:
    if v is None:
        return False
    v = v.strip().lower()
    return v in {"1", "true", "yes", "on"}

host = (os.environ.get("REDIS_HOST") or "127.0.0.1").strip()
port_raw = (os.environ.get("REDIS_PORT") or "6379").strip()
db_raw = (os.environ.get("REDIS_DB") or "0").strip()
user = (os.environ.get("REDIS_USERNAME") or "").strip()
password = os.environ.get("REDIS_PASSWORD") or ""

# Treat the common requirepass setup as password-only (no username in URL).
if user.lower() == "default":
    user = ""

try:
    port = int(port_raw)
except ValueError as e:
    raise SystemExit(f"REDIS_PORT must be an integer, got {port_raw!r}") from e

try:
    db = int(db_raw)
except ValueError as e:
    raise SystemExit(f"REDIS_DB must be an integer, got {db_raw!r}") from e

scheme = "rediss" if is_truthy(os.environ.get("REDIS_SSL")) else "redis"

userinfo = ""
if user or password:
    if user:
        userinfo += quote(user, safe="")
    if password:
        userinfo += ":" + quote(password, safe="")
    userinfo += "@"

print(f"{scheme}://{userinfo}{host}:{port}/{db}")
PY
	) || error_log "Failed to build Redis URL for RQ worker (check REDIS_* env vars)"

	# Set PYTHONPATH so RQ can find the tasks module
	PYTHONPATH="/backend:${PYTHONPATH-}" rq worker \
		--path /backend \
		--pid /tmp/rq_worker.pid \
		--url "${redis_url}" \
		--results-ttl "${TASK_RESULT_TTL:-86400}" \
		high default low &
}

start_bin_watcher() {
	info_log "Starting watcher"
	watchfiles \
		--target-type command \
		"opentelemetry-instrument --service_name '${OTEL_SERVICE_NAME_PREFIX-}watcher' python3 watcher.py" \
		/romm/library &
	WATCHER_PID=$!
	echo "${WATCHER_PID}" >/tmp/watcher.pid
}

watchdog_process_pid() {
	PROCESS=$1
	if [[ -f "/tmp/${PROCESS}.pid" ]]; then
		# Check if the pid we last wrote to our state file is actually active
		PID=$(cat "/tmp/${PROCESS}.pid") || true
		if [[ ! -d "/proc/${PID}" ]]; then
			start_bin_"${PROCESS}"
		fi
	else
		# Start process if we dont have a corresponding PID file
		start_bin_"${PROCESS}"
	fi
}

stop_process_pid() {
	PROCESS=$1
	if [[ -f "/tmp/${PROCESS}.pid" ]]; then
		PID=$(cat "/tmp/${PROCESS}.pid") || true
		if [[ -d "/proc/${PID}" ]]; then
			info_log "Stopping ${PROCESS}"
			kill "${PID}" || true
			# wait for process exit
			while [[ -e "/proc/${PID}" ]]; do sleep 0.1; done
		fi
	fi
}

shutdown() {
	# shutdown in reverse order
	stop_process_pid rq_worker
	stop_process_pid rq_scheduler
	stop_process_pid watcher
	stop_process_pid nginx
	stop_process_pid gunicorn
	stop_process_pid valkey-server
}

# switch to backend directory
cd /backend || { error_log "/backend directory doesn't seem to exist"; }

print_banner

# setup trap handler
exited=0
trap 'exited=1 && shutdown' SIGINT SIGTERM EXIT

# clear any leftover PID files
rm /tmp/*.pid -f

# Disable OpenTelemetry if no OTEL_ prefixed environment variables are set
if ! printenv | grep -q '^OTEL_'; then
	info_log "No OpenTelemetry environment variables found, disabling OpenTelemetry SDK"
	export OTEL_SDK_DISABLED=true
fi

# Set ROMM_AUTH_SECRET_KEY if not already set
if [[ -z ${ROMM_AUTH_SECRET_KEY} ]]; then
	ROMM_AUTH_SECRET_KEY=$(python3 -c "import secrets; print(secrets.token_hex(32))")
	info_log "ROMM_AUTH_SECRET_KEY not set, generating random secret key"
	export ROMM_AUTH_SECRET_KEY
fi

# Start Valkey server if REDIS_HOST is not set (which would mean user is using an external Redis/Valkey)
if [[ -z ${REDIS_HOST} ]]; then
	watchdog_process_pid valkey-server
else
	info_log "REDIS_HOST is set, not starting internal valkey-server"
fi

# Run needed database migrations once at startup
info_log "Running database migrations"
if alembic upgrade head; then
	info_log "Database migrations succeeded"
else
	error_log "Failed to run database migrations"
fi

# Startup process requires database and cache to be already available
run_startup

# main loop
while ! ((exited)); do
	watchdog_process_pid gunicorn

	# only start the scheduler if enabled
	if [[ ${ENABLE_SCHEDULED_RESCAN} == "true" || ${ENABLE_SCHEDULED_UPDATE_SWITCH_TITLEDB} == "true" || ${ENABLE_SCHEDULED_UPDATE_LAUNCHBOX_METADATA} == "true" ]]; then
		watchdog_process_pid rq_scheduler
	fi

	watchdog_process_pid rq_worker

	# only start the watcher if enabled
	if [[ ${ENABLE_RESCAN_ON_FILESYSTEM_CHANGE} == "true" ]]; then
		watchdog_process_pid watcher
	fi

	watchdog_process_pid nginx

	# check for died processes every 5 seconds
	sleep 5
done
